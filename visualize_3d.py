#!/usr/bin/env python3
"""
Enhanced 3D Electromagnetic Field Visualization with PyVista

This module provides a comprehensive object-oriented framework for visualizing
electromagnetic field data generated by the magrslib Rust library.

Features:
- Automatic metadata parsing for scene setup
- Multi-source geometry rendering (magnets, current loops, etc.)
- Adaptive field visualization strategies
- Professional quality output for scientific publications
- Interactive controls and animation support

Requirements:
    pip install pyvista numpy matplotlib

Usage:
    python3 visualize_3d.py [metadata.json]
    python3 visualize_3d.py --interactive [metadata.json]
    python3 visualize_3d.py --batch [metadata.json] --output scene.png
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
import warnings

import numpy as np
import pyvista as pv
from pyvista import themes

# Suppress PyVista warnings for cleaner output
warnings.filterwarnings("ignore", category=UserWarning, module="pyvista")


class SourceRenderer:
    """Handles rendering of electromagnetic sources (magnets, current loops, etc.)"""

    # Color scheme for different source types
    SOURCE_COLORS = {
        'MagnetCuboid': 'lightblue',
        'MagnetCylinder': 'lightcoral',
        'MagnetSphere': 'lightgreen',
        'CurrentCircle': 'gold',
        'CurrentPolyline': 'orange',
        'Dipole': 'purple'
    }

    def __init__(self):
        self.geometries = []

    def create_cuboid_mesh(self, position: np.ndarray, orientation: np.ndarray,
                          dimension: List[float]) -> pv.PolyData:
        """Create a cuboid magnet mesh"""
        # Create box centered at origin
        mesh = pv.Box(bounds=[
            -dimension[0]/2, dimension[0]/2,
            -dimension[1]/2, dimension[1]/2,
            -dimension[2]/2, dimension[2]/2
        ])

        # Apply rotation (quaternion to rotation matrix)
        if not np.allclose(orientation, [1, 0, 0, 0]):
            # Convert quaternion to rotation matrix
            w, x, y, z = orientation
            rotation_matrix = np.array([
                [1-2*(y*y+z*z), 2*(x*y-w*z), 2*(x*z+w*y)],
                [2*(x*y+w*z), 1-2*(x*x+z*z), 2*(y*z-w*x)],
                [2*(x*z-w*y), 2*(y*z+w*x), 1-2*(x*x+y*y)]
            ])
            mesh = mesh.rotate_vector(rotation_matrix.flatten(), inplace=False)

        # Translate to position
        mesh = mesh.translate(position, inplace=False)
        return mesh

    def create_cylinder_mesh(self, position: np.ndarray, orientation: np.ndarray,
                           diameter: float, height: float) -> pv.PolyData:
        """Create a cylindrical magnet mesh"""
        mesh = pv.Cylinder(radius=diameter/2, height=height, direction=(0, 0, 1))

        # Apply rotation and translation (similar to cuboid)
        if not np.allclose(orientation, [1, 0, 0, 0]):
            w, x, y, z = orientation
            rotation_matrix = np.array([
                [1-2*(y*y+z*z), 2*(x*y-w*z), 2*(x*z+w*y)],
                [2*(x*y+w*z), 1-2*(x*x+z*z), 2*(y*z-w*x)],
                [2*(x*z-w*y), 2*(y*z+w*x), 1-2*(x*x+y*y)]
            ])
            mesh = mesh.rotate_vector(rotation_matrix.flatten(), inplace=False)

        mesh = mesh.translate(position, inplace=False)
        return mesh

    def create_sphere_mesh(self, position: np.ndarray, diameter: float) -> pv.PolyData:
        """Create a spherical magnet mesh"""
        mesh = pv.Sphere(radius=diameter/2, center=position)
        return mesh

    def create_circle_mesh(self, position: np.ndarray, orientation: np.ndarray,
                          diameter: float, tube_radius: Optional[float] = None) -> pv.PolyData:
        """Create a current loop mesh"""
        if tube_radius is None:
            tube_radius = diameter * 0.01  # 1% of diameter

        # Create circle in xy-plane
        theta = np.linspace(0, 2*np.pi, 100)
        radius = diameter / 2
        points = np.column_stack([
            radius * np.cos(theta),
            radius * np.sin(theta),
            np.zeros(len(theta))
        ])

        # Create polyline and tube
        mesh = pv.PolyData(points)
        mesh.lines = np.hstack([[len(points)] + list(range(len(points))) + [0]])
        mesh = mesh.tube(radius=tube_radius)

        # Apply rotation and translation
        if not np.allclose(orientation, [1, 0, 0, 0]):
            w, x, y, z = orientation
            rotation_matrix = np.array([
                [1-2*(y*y+z*z), 2*(x*y-w*z), 2*(x*z+w*y)],
                [2*(x*y+w*z), 1-2*(x*x+z*z), 2*(y*z-w*x)],
                [2*(x*z-w*y), 2*(y*z+w*x), 1-2*(x*x+y*y)]
            ])
            mesh = mesh.rotate_vector(rotation_matrix.flatten(), inplace=False)

        mesh = mesh.translate(position, inplace=False)
        return mesh

    def create_dipole_mesh(self, position: np.ndarray, orientation: np.ndarray,
                          moment_magnitude: float, scale: float = 0.001) -> pv.PolyData:
        """Create a magnetic dipole visualization (arrow)"""
        # Create arrow pointing in z-direction
        arrow = pv.Arrow(start=(0, 0, -scale/2), direction=(0, 0, 1),
                        scale=scale, shaft_radius=scale*0.1, tip_radius=scale*0.2)

        # Apply rotation and translation
        if not np.allclose(orientation, [1, 0, 0, 0]):
            w, x, y, z = orientation
            rotation_matrix = np.array([
                [1-2*(y*y+z*z), 2*(x*y-w*z), 2*(x*z+w*y)],
                [2*(x*y+w*z), 1-2*(x*x+z*z), 2*(y*z-w*x)],
                [2*(x*z-w*y), 2*(y*z+w*x), 1-2*(x*x+y*y)]
            ])
            arrow = arrow.rotate_vector(rotation_matrix.flatten(), inplace=False)

        arrow = arrow.translate(position, inplace=False)
        return arrow

    def render_source(self, source_metadata: Dict) -> Tuple[pv.PolyData, str, str]:
        """Render a single source from metadata"""
        source_type = source_metadata['source_type']
        position = np.array(source_metadata['position'])
        orientation = np.array(source_metadata['orientation'])
        params = source_metadata['parameters']

        color = self.SOURCE_COLORS.get(source_type, 'gray')

        if source_type == 'MagnetCuboid':
            dimension = params['dimension']
            mesh = self.create_cuboid_mesh(position, orientation, dimension)
            label = f"Cuboid Magnet ({dimension[0]*1000:.1f}×{dimension[1]*1000:.1f}×{dimension[2]*1000:.1f}mm)"

        elif source_type == 'MagnetCylinder':
            diameter = params['diameter']
            height = params['height']
            mesh = self.create_cylinder_mesh(position, orientation, diameter, height)
            label = f"Cylinder Magnet (⌀{diameter*1000:.1f}×{height*1000:.1f}mm)"

        elif source_type == 'MagnetSphere':
            diameter = params['diameter']
            mesh = self.create_sphere_mesh(position, diameter)
            label = f"Sphere Magnet (⌀{diameter*1000:.1f}mm)"

        elif source_type == 'CurrentCircle':
            diameter = params['diameter']
            current = params['current']
            mesh = self.create_circle_mesh(position, orientation, diameter)
            label = f"Current Loop (⌀{diameter*1000:.1f}mm, {current:.1f}A)"

        elif source_type == 'Dipole':
            moment = np.array(params['moment'])
            moment_magnitude = np.linalg.norm(moment)
            mesh = self.create_dipole_mesh(position, orientation, moment_magnitude)
            label = f"Dipole ({moment_magnitude:.2e} A·m²)"

        else:
            # Unknown source type - create a simple sphere
            mesh = pv.Sphere(radius=0.001, center=position)
            label = f"Unknown Source ({source_type})"
            color = 'red'

        return mesh, color, label


class FieldVisualizer:
    """Main visualization class for electromagnetic field data"""

    def __init__(self, metadata_path: Optional[str] = None, interactive: bool = True):
        self.metadata_path = metadata_path
        self.interactive = interactive
        self.metadata = None
        self.field_mesh = None
        self.plotter = None
        self.source_renderer = SourceRenderer()

        # Load metadata if provided
        if metadata_path:
            self.load_metadata(metadata_path)

    def load_metadata(self, metadata_path: str):
        """Load visualization metadata from JSON file"""
        try:
            with open(metadata_path, 'r') as f:
                self.metadata = json.load(f)
            print(f"✓ Loaded metadata from {metadata_path}")
        except Exception as e:
            print(f"✗ Failed to load metadata: {e}")
            self.metadata = None

    def load_field_data(self, vtk_path: Optional[str] = None) -> bool:
        """Load field data from VTK file"""
        if vtk_path is None:
            if self.metadata and 'files' in self.metadata:
                # Prefer absolute path if available, fall back to relative
                if 'field_vtk_absolute' in self.metadata['files'] and self.metadata['files']['field_vtk_absolute']:
                    vtk_path = self.metadata['files']['field_vtk_absolute']
                else:
                    vtk_path = self.metadata['files']['field_vtk']
            else:
                vtk_path = 'bfield_3d.vtk'  # Default fallback

        try:
            print(f"Loading field data from {vtk_path}...")
            self.field_mesh = pv.read(vtk_path)

            # Calculate field magnitude if not present
            if 'B' in self.field_mesh.array_names and 'B_magnitude' not in self.field_mesh.array_names:
                b_vectors = self.field_mesh['B']
                b_magnitude = np.linalg.norm(b_vectors, axis=1)
                self.field_mesh['B_magnitude'] = b_magnitude

            print(f"✓ Field data loaded successfully")
            print(f"  Grid dimensions: {self.field_mesh.dimensions}")
            print(f"  Number of points: {self.field_mesh.n_points}")
            print(f"  Field arrays: {self.field_mesh.array_names}")

            # Print field statistics
            if 'B_magnitude' in self.field_mesh.array_names:
                b_mag = self.field_mesh['B_magnitude']
                print(f"  Field magnitude range: {b_mag.min():.3e} - {b_mag.max():.3e} T")

            return True

        except Exception as e:
            print(f"✗ Failed to load field data: {e}")
            return False

    def setup_plotter(self):
        """Initialize the PyVista plotter with appropriate settings"""
        self.plotter = pv.Plotter()
        self.plotter.set_background('white')

        # Apply camera settings from metadata if available
        if self.metadata and 'visualization_hints' in self.metadata:
            hints = self.metadata['visualization_hints']
            self.plotter.camera_position = [
                hints['camera_position'],
                hints['camera_focal_point'],
                (0, 0, 1)  # View up
            ]

    def render_sources(self):
        """Render all electromagnetic sources from metadata"""
        if not self.metadata or 'sources' not in self.metadata:
            print("No source metadata available for rendering")
            return

        print(f"Rendering {len(self.metadata['sources'])} sources...")

        for i, source_meta in enumerate(self.metadata['sources']):
            try:
                mesh, color, label = self.source_renderer.render_source(source_meta)

                self.plotter.add_mesh(
                    mesh,
                    color=color,
                    opacity=0.7,
                    label=label,
                    show_edges=True,
                    edge_color='black',
                    line_width=1
                )
                print(f"  ✓ {label}")

            except Exception as e:
                print(f"  ✗ Failed to render source {i}: {e}")

    def render_field_lines(self, n_lines: int = 50, line_thickness: Optional[float] = None):
        """Generate and render magnetic field lines"""
        if self.field_mesh is None or 'B' not in self.field_mesh.array_names:
            print("No field data available for streamlines")
            return

        print(f"Generating {n_lines} field lines...")

        # Use adaptive seeding strategy from metadata
        if self.metadata and 'visualization_hints' in self.metadata:
            hints = self.metadata['visualization_hints']
            strategy = hints.get('streamline_strategy', 'adaptive_circle')
            scale = hints.get('scene_scale', 0.01)
        else:
            strategy = 'adaptive_circle'
            scale = 0.01

        try:
            if strategy == 'adaptive_circle':
                # Create circular seed pattern adapted to scene scale
                streamlines = self.field_mesh.streamlines(
                    vectors='B',
                    source_center=(0, 0, 0),
                    source_radius=scale * 1.5,
                    n_points=n_lines,
                    max_time=scale * 50,
                    integration_direction='both'
                )
            else:
                # Default streamline generation
                streamlines = self.field_mesh.streamlines(
                    vectors='B',
                    n_points=n_lines,
                    max_time=0.5,
                    integration_direction='both'
                )

            if streamlines.n_points > 0:
                print(f"✓ Generated {streamlines.n_lines} field lines")

                # Determine tube radius using adaptive absolute thickness
                if line_thickness is not None:
                    # User-specified absolute thickness
                    tube_radius = line_thickness
                else:
                    # Adaptive thickness based on source characteristic sizes
                    if self.metadata and 'sources' in self.metadata:
                        # Find minimum characteristic size from all sources
                        char_sizes = [source['characteristic_size'] for source in self.metadata['sources']]
                        min_char_size = min(char_sizes)
                        # Use 1% of smallest source characteristic size
                        tube_radius = min_char_size * 0.01
                        # Apply absolute minimum for very small sources
                        tube_radius = max(tube_radius, 0.00005)  # 0.05mm minimum
                    else:
                        # Fallback for cases without metadata
                        tube_radius = 0.0001  # 0.1mm default

                # Get colormap range from metadata or auto-scale
                if (self.metadata and 'visualization_hints' in self.metadata
                    and 'colormap_range' in self.metadata['visualization_hints']):
                    clim = self.metadata['visualization_hints']['colormap_range']
                else:
                    b_mag = self.field_mesh['B_magnitude']
                    clim = [b_mag.min(), b_mag.max()]

                self.plotter.add_mesh(
                    streamlines.tube(radius=tube_radius),
                    scalars='B_magnitude',
                    cmap='plasma',
                    opacity=0.8,
                    label='Field lines',
                    clim=clim,
                    scalar_bar_args={
                        'title': 'B-field magnitude (T)',
                        'title_font_size': 12,
                        'label_font_size': 10,
                        'n_labels': 5,
                        'fmt': '%.2e'
                    }
                )
            else:
                print("⚠ No field lines generated - check field data and bounds")

        except Exception as e:
            print(f"✗ Failed to generate field lines: {e}")

    def add_scene_elements(self):
        """Add axes, title, and other scene elements"""
        # Add coordinate axes
        self.plotter.add_axes(
            xlabel='X (m)',
            ylabel='Y (m)',
            zlabel='Z (m)',
            line_width=3
        )

        # Add title from metadata or create default
        if self.metadata and 'sources' in self.metadata:
            n_sources = len(self.metadata['sources'])
            title = f"Electromagnetic Field Visualization ({n_sources} sources)"
        else:
            title = "Electromagnetic Field Visualization"

        self.plotter.add_text(
            title,
            position='upper_left',
            font_size=12,
            color='black'
        )

    def create_visualization(self, vtk_path: Optional[str] = None,
                           n_field_lines: int = 50, line_thickness: Optional[float] = None) -> bool:
        """Create complete visualization"""
        # Load field data
        if not self.load_field_data(vtk_path):
            return False

        # Setup plotter
        self.setup_plotter()

        # Render sources
        self.render_sources()

        # Render field lines
        self.render_field_lines(n_field_lines, line_thickness)

        # Add scene elements
        self.add_scene_elements()

        return True

    def show(self, save_path: Optional[str] = None):
        """Display the visualization"""
        if self.plotter is None:
            print("No visualization to show - call create_visualization() first")
            return

        if save_path:
            print(f"Saving visualization to {save_path}")
            self.plotter.show(screenshot=save_path, interactive=False)
        elif self.interactive:
            print("\nOpening interactive 3D viewer...")
            print("  - Left mouse: Rotate")
            print("  - Right mouse: Zoom")
            print("  - Middle mouse: Pan")
            print("  - 'q': Quit")
            print("  - 's': Save screenshot")
            self.plotter.show()
        else:
            self.plotter.show(interactive=False)


class SceneBuilder:
    """High-level interface for building complex electromagnetic scenes"""

    def __init__(self):
        self.visualizer = FieldVisualizer()

    def from_metadata(self, metadata_path: str, **kwargs) -> FieldVisualizer:
        """Build scene from metadata file"""
        self.visualizer = FieldVisualizer(metadata_path, **kwargs)
        return self.visualizer

    def create_helmholtz_preset(self, coil_radius: float = 0.05,
                               separation: float = 0.05, current: float = 1.0):
        """Create a Helmholtz coil configuration preset"""
        # This would be implemented to create a standard Helmholtz coil setup
        # For now, just placeholder
        print(f"Helmholtz coil preset: radius={coil_radius}m, separation={separation}m, current={current}A")
        print("(Preset implementation pending)")

    def create_magnet_array_preset(self, array_type: str = 'halbach'):
        """Create magnet array presets (Halbach, etc.)"""
        print(f"Magnet array preset: {array_type}")
        print("(Preset implementation pending)")


def main():
    """Main entry point for the visualization script"""
    parser = argparse.ArgumentParser(description='Electromagnetic Field Visualization')
    parser.add_argument('metadata', nargs='?', default=None,
                       help='Path to metadata JSON file')
    parser.add_argument('--interactive', action='store_true', default=True,
                       help='Enable interactive mode (default)')
    parser.add_argument('--batch', action='store_true',
                       help='Run in batch mode (non-interactive)')
    parser.add_argument('--output', '-o', type=str,
                       help='Output file for batch mode')
    parser.add_argument('--field-lines', '-f', type=int, default=50,
                       help='Number of field lines to generate')
    parser.add_argument('--line-thickness', '-t', type=float, default=None,
                       help='Field line thickness in meters (default: adaptive based on source size)')
    parser.add_argument('--vtk', type=str,
                       help='Override VTK file path')

    args = parser.parse_args()

    # Determine metadata file
    metadata_path = args.metadata
    if metadata_path is None:
        # Look for metadata files in current directory
        candidates = list(Path('.').glob('*metadata*.json'))
        if candidates:
            metadata_path = str(candidates[0])
            print(f"Auto-detected metadata file: {metadata_path}")
        else:
            print("No metadata file specified or found")

    # Create visualizer
    interactive = not args.batch
    visualizer = FieldVisualizer(metadata_path, interactive=interactive)

    # Create visualization
    success = visualizer.create_visualization(args.vtk, args.field_lines, args.line_thickness)
    if not success:
        print("Failed to create visualization")
        sys.exit(1)

    # Show or save
    if args.batch and args.output:
        visualizer.show(save_path=args.output)
    else:
        visualizer.show()


if __name__ == '__main__':
    main()